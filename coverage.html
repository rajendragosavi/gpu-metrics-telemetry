
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gen: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gpu-metric-collector/api/gen/telemetry.pb.go (0.0%)</option>
				
				<option value="file1">gpu-metric-collector/api/gen/telemetry_grpc.pb.go (0.0%)</option>
				
				<option value="file2">gpu-metric-collector/cmd/api-gateway/main.go (0.0%)</option>
				
				<option value="file3">gpu-metric-collector/cmd/api-gateway/server.go (67.9%)</option>
				
				<option value="file4">gpu-metric-collector/cmd/collector/main.go (53.9%)</option>
				
				<option value="file5">gpu-metric-collector/cmd/mq-broker/main.go (0.0%)</option>
				
				<option value="file6">gpu-metric-collector/cmd/streamer/main.go (31.2%)</option>
				
				<option value="file7">gpu-metric-collector/internal/broker/broker.go (93.7%)</option>
				
				<option value="file8">gpu-metric-collector/internal/storage/influx.go (0.0%)</option>
				
				<option value="file9">gpu-metric-collector/internal/storage/memory.go (100.0%)</option>
				
				<option value="file10">gpu-metric-collector/internal/storage/sqlite.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.11
//         protoc        v3.21.12
// source: telemetry.proto

package telemetryv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TelemetryData struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ProducerId    string                 `protobuf:"bytes,1,opt,name=producer_id,json=producerId,proto3" json:"producer_id,omitempty"`                                                     // Streamer identity (e.g., pod name)
        HostId        string                 `protobuf:"bytes,2,opt,name=host_id,json=hostId,proto3" json:"host_id,omitempty"`                                                                 // Hostname/node
        GpuId         string                 `protobuf:"bytes,3,opt,name=gpu_id,json=gpuId,proto3" json:"gpu_id,omitempty"`                                                                    // GPU identifier
        Ts            *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=ts,proto3" json:"ts,omitempty"`                                                                                       // Source timestamp from streamer
        Metrics       map[string]float64     `protobuf:"bytes,5,rep,name=metrics,proto3" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"` // Arbitrary numeric metrics
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TelemetryData) Reset() <span class="cov0" title="0">{
        *x = TelemetryData{}
        mi := &amp;file_telemetry_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TelemetryData) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TelemetryData) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TelemetryData) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_telemetry_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TelemetryData.ProtoReflect.Descriptor instead.
func (*TelemetryData) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_telemetry_proto_rawDescGZIP(), []int{0}
}</span>

func (x *TelemetryData) GetProducerId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProducerId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelemetryData) GetHostId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HostId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelemetryData) GetGpuId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GpuId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TelemetryData) GetTs() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TelemetryData) GetMetrics() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metrics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TelemetryBatch struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Items         []*TelemetryData       `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TelemetryBatch) Reset() <span class="cov0" title="0">{
        *x = TelemetryBatch{}
        mi := &amp;file_telemetry_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TelemetryBatch) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TelemetryBatch) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TelemetryBatch) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_telemetry_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TelemetryBatch.ProtoReflect.Descriptor instead.
func (*TelemetryBatch) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_telemetry_proto_rawDescGZIP(), []int{1}
}</span>

func (x *TelemetryBatch) GetItems() []*TelemetryData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Items
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PublishResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Accepted      int64                  `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"` // number of items enqueued
        Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`      // OK, BACKPRESSURE, ERROR
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PublishResponse) Reset() <span class="cov0" title="0">{
        *x = PublishResponse{}
        mi := &amp;file_telemetry_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PublishResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PublishResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PublishResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_telemetry_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PublishResponse.ProtoReflect.Descriptor instead.
func (*PublishResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_telemetry_proto_rawDescGZIP(), []int{2}
}</span>

func (x *PublishResponse) GetAccepted() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Accepted
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PublishResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SubscriptionRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Group         string                 `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"` // consumer group (optional)
        Topic         string                 `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"` // topic (optional for future use)
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SubscriptionRequest) Reset() <span class="cov0" title="0">{
        *x = SubscriptionRequest{}
        mi := &amp;file_telemetry_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SubscriptionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubscriptionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubscriptionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_telemetry_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubscriptionRequest.ProtoReflect.Descriptor instead.
func (*SubscriptionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_telemetry_proto_rawDescGZIP(), []int{3}
}</span>

func (x *SubscriptionRequest) GetGroup() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Group
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubscriptionRequest) GetTopic() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Topic
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_telemetry_proto protoreflect.FileDescriptor

const file_telemetry_proto_rawDesc = "" +
        "\n" +
        "\x0ftelemetry.proto\x12\ftelemetry.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\x8c\x02\n" +
        "\rTelemetryData\x12\x1f\n" +
        "\vproducer_id\x18\x01 \x01(\tR\n" +
        "producerId\x12\x17\n" +
        "\ahost_id\x18\x02 \x01(\tR\x06hostId\x12\x15\n" +
        "\x06gpu_id\x18\x03 \x01(\tR\x05gpuId\x12*\n" +
        "\x02ts\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x02ts\x12B\n" +
        "\ametrics\x18\x05 \x03(\v2(.telemetry.v1.TelemetryData.MetricsEntryR\ametrics\x1a:\n" +
        "\fMetricsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\"C\n" +
        "\x0eTelemetryBatch\x121\n" +
        "\x05items\x18\x01 \x03(\v2\x1b.telemetry.v1.TelemetryDataR\x05items\"E\n" +
        "\x0fPublishResponse\x12\x1a\n" +
        "\baccepted\x18\x01 \x01(\x03R\baccepted\x12\x16\n" +
        "\x06status\x18\x02 \x01(\tR\x06status\"A\n" +
        "\x13SubscriptionRequest\x12\x14\n" +
        "\x05group\x18\x01 \x01(\tR\x05group\x12\x14\n" +
        "\x05topic\x18\x02 \x01(\tR\x05topic2\xa7\x01\n" +
        "\tTelemetry\x12K\n" +
        "\fPublishBatch\x12\x1c.telemetry.v1.TelemetryBatch\x1a\x1d.telemetry.v1.PublishResponse\x12M\n" +
        "\tSubscribe\x12!.telemetry.v1.SubscriptionRequest\x1a\x1b.telemetry.v1.TelemetryData0\x01B7Z5gpu-metric-collector/api/gen/telemetry/v1;telemetryv1b\x06proto3"

var (
        file_telemetry_proto_rawDescOnce sync.Once
        file_telemetry_proto_rawDescData []byte
)

func file_telemetry_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_telemetry_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_telemetry_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_telemetry_proto_rawDesc), len(file_telemetry_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_telemetry_proto_rawDescData</span>
}

var file_telemetry_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_telemetry_proto_goTypes = []any{
        (*TelemetryData)(nil),         // 0: telemetry.v1.TelemetryData
        (*TelemetryBatch)(nil),        // 1: telemetry.v1.TelemetryBatch
        (*PublishResponse)(nil),       // 2: telemetry.v1.PublishResponse
        (*SubscriptionRequest)(nil),   // 3: telemetry.v1.SubscriptionRequest
        nil,                           // 4: telemetry.v1.TelemetryData.MetricsEntry
        (*timestamppb.Timestamp)(nil), // 5: google.protobuf.Timestamp
}
var file_telemetry_proto_depIdxs = []int32{
        5, // 0: telemetry.v1.TelemetryData.ts:type_name -&gt; google.protobuf.Timestamp
        4, // 1: telemetry.v1.TelemetryData.metrics:type_name -&gt; telemetry.v1.TelemetryData.MetricsEntry
        0, // 2: telemetry.v1.TelemetryBatch.items:type_name -&gt; telemetry.v1.TelemetryData
        1, // 3: telemetry.v1.Telemetry.PublishBatch:input_type -&gt; telemetry.v1.TelemetryBatch
        3, // 4: telemetry.v1.Telemetry.Subscribe:input_type -&gt; telemetry.v1.SubscriptionRequest
        2, // 5: telemetry.v1.Telemetry.PublishBatch:output_type -&gt; telemetry.v1.PublishResponse
        0, // 6: telemetry.v1.Telemetry.Subscribe:output_type -&gt; telemetry.v1.TelemetryData
        5, // [5:7] is the sub-list for method output_type
        3, // [3:5] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_telemetry_proto_init() }</span>
func file_telemetry_proto_init() <span class="cov0" title="0">{
        if File_telemetry_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_telemetry_proto_rawDesc), len(file_telemetry_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_telemetry_proto_goTypes,
                DependencyIndexes: file_telemetry_proto_depIdxs,
                MessageInfos:      file_telemetry_proto_msgTypes,
        }.Build()
        File_telemetry_proto = out.File
        file_telemetry_proto_goTypes = nil
        file_telemetry_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: telemetry.proto

package telemetryv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Telemetry_PublishBatch_FullMethodName = "/telemetry.v1.Telemetry/PublishBatch"
        Telemetry_Subscribe_FullMethodName    = "/telemetry.v1.Telemetry/Subscribe"
)

// TelemetryClient is the client API for Telemetry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TelemetryClient interface {
        // Streamers publish batches (unary for simplicity; can be upgraded to client streaming later)
        PublishBatch(ctx context.Context, in *TelemetryBatch, opts ...grpc.CallOption) (*PublishResponse, error)
        // Collectors receive a server-side stream of telemetry data (work-queue style)
        Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TelemetryData], error)
}

type telemetryClient struct {
        cc grpc.ClientConnInterface
}

func NewTelemetryClient(cc grpc.ClientConnInterface) TelemetryClient <span class="cov0" title="0">{
        return &amp;telemetryClient{cc}
}</span>

func (c *telemetryClient) PublishBatch(ctx context.Context, in *TelemetryBatch, opts ...grpc.CallOption) (*PublishResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(PublishResponse)
        err := c.cc.Invoke(ctx, Telemetry_PublishBatch_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *telemetryClient) Subscribe(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TelemetryData], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;Telemetry_ServiceDesc.Streams[0], Telemetry_Subscribe_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[SubscriptionRequest, TelemetryData]{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Telemetry_SubscribeClient = grpc.ServerStreamingClient[TelemetryData]

// TelemetryServer is the server API for Telemetry service.
// All implementations must embed UnimplementedTelemetryServer
// for forward compatibility.
type TelemetryServer interface {
        // Streamers publish batches (unary for simplicity; can be upgraded to client streaming later)
        PublishBatch(context.Context, *TelemetryBatch) (*PublishResponse, error)
        // Collectors receive a server-side stream of telemetry data (work-queue style)
        Subscribe(*SubscriptionRequest, grpc.ServerStreamingServer[TelemetryData]) error
        mustEmbedUnimplementedTelemetryServer()
}

// UnimplementedTelemetryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTelemetryServer struct{}

func (UnimplementedTelemetryServer) PublishBatch(context.Context, *TelemetryBatch) (*PublishResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method PublishBatch not implemented")
}</span>
func (UnimplementedTelemetryServer) Subscribe(*SubscriptionRequest, grpc.ServerStreamingServer[TelemetryData]) error <span class="cov0" title="0">{
        return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}</span>
func (UnimplementedTelemetryServer) mustEmbedUnimplementedTelemetryServer() {<span class="cov0" title="0">}</span>
func (UnimplementedTelemetryServer) testEmbeddedByValue()                   {<span class="cov0" title="0">}</span>

// UnsafeTelemetryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TelemetryServer will
// result in compilation errors.
type UnsafeTelemetryServer interface {
        mustEmbedUnimplementedTelemetryServer()
}

func RegisterTelemetryServer(s grpc.ServiceRegistrar, srv TelemetryServer) <span class="cov0" title="0">{
        // If the following call panics, it indicates UnimplementedTelemetryServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Telemetry_ServiceDesc, srv)</span>
}

func _Telemetry_PublishBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TelemetryBatch)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TelemetryServer).PublishBatch(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Telemetry_PublishBatch_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TelemetryServer).PublishBatch(ctx, req.(*TelemetryBatch))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Telemetry_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(SubscriptionRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(TelemetryServer).Subscribe(m, &amp;grpc.GenericServerStream[SubscriptionRequest, TelemetryData]{ServerStream: stream})</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Telemetry_SubscribeServer = grpc.ServerStreamingServer[TelemetryData]

// Telemetry_ServiceDesc is the grpc.ServiceDesc for Telemetry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Telemetry_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "telemetry.v1.Telemetry",
        HandlerType: (*TelemetryServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "PublishBatch",
                        Handler:    _Telemetry_PublishBatch_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "Subscribe",
                        Handler:       _Telemetry_Subscribe_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "telemetry.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "flag"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "gpu-metric-collector/internal/storage"
)

func main() <span class="cov0" title="0">{
        addr := flag.String("addr", ":8080", "HTTP listen address")
        influxURL := flag.String("influx_url", "", "InfluxDB URL, e.g. http://localhost:8086")
        influxOrg := flag.String("influx_org", "", "InfluxDB organization")
        influxBucket := flag.String("influx_bucket", "", "InfluxDB bucket")
        influxToken := flag.String("influx_token", "", "InfluxDB API token")
        flag.Parse()

        var store storage.Store
        if *influxURL != "" &amp;&amp; *influxOrg != "" &amp;&amp; *influxBucket != "" &amp;&amp; *influxToken != "" </span><span class="cov0" title="0">{
                s, err := storage.NewInfluxStore(*influxURL, *influxOrg, *influxBucket, *influxToken)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("open influx store: %v", err)
                }</span>
                <span class="cov0" title="0">store = s
                log.Printf("api-gateway: using influx store url=%s org=%s bucket=%s", *influxURL, *influxOrg, *influxBucket)</span>
        } else<span class="cov0" title="0"> {
                store = storage.NewMemoryStore()
                log.Printf("api-gateway: using in-memory store")
        }</span>

        <span class="cov0" title="0">handler := newServer(store)
        server := &amp;http.Server{Addr: *addr, Handler: handler}

        // graceful shutdown
        go func() </span><span class="cov0" title="0">{
                log.Printf("api-gateway: listening on %s with /api/v1 endpoints", *addr)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("http server: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sigCh
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        _ = server.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/json"
        "log"
        "net/http"
        "strings"
        "time"

        "gpu-metric-collector/internal/storage"
)

// newServer builds an http.Handler with all routes, for testing and for main().
func newServer(store storage.Store) http.Handler <span class="cov10" title="4">{
        mux := http.NewServeMux()

        mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte("ok"))
        }</span>)

        <span class="cov10" title="4">mux.HandleFunc("/api/v1/gpus", func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>
                <span class="cov1" title="1">gpus, err := store.ListGPUs()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("api: list gpus error: %v", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov1" title="1">writeJSON(w, http.StatusOK, gpus)</span>
        })

        <span class="cov10" title="4">mux.HandleFunc("/api/v1/gpus/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="3">{
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>
                <span class="cov8" title="3">p := strings.TrimPrefix(r.URL.Path, "/api/v1/gpus/")
                parts := strings.Split(p, "/")
                if len(parts) != 2 || parts[1] != "telemetry" || parts[0] == "" </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusNotFound)
                        return
                }</span>
                <span class="cov5" title="2">gpuID := parts[0]

                var startPtr, endPtr *time.Time
                if s := r.URL.Query().Get("start_time"); s != "" </span><span class="cov5" title="2">{
                        t, err := time.Parse(time.RFC3339, s)
                        if err != nil </span><span class="cov1" title="1">{
                                http.Error(w, "invalid start_time", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov1" title="1">startPtr = &amp;t</span>
                }
                <span class="cov1" title="1">if s := r.URL.Query().Get("end_time"); s != "" </span><span class="cov1" title="1">{
                        t, err := time.Parse(time.RFC3339, s)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "invalid end_time", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov1" title="1">endPtr = &amp;t</span>
                }

                <span class="cov1" title="1">items, err := store.QueryTelemetry(gpuID, startPtr, endPtr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("api: query telemetry error gpu=%s start=%v end=%v: %v", gpuID, startPtr, endPtr, err)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov1" title="1">writeJSON(w, http.StatusOK, items)</span>
        })

        <span class="cov10" title="4">mux.HandleFunc("/openapi.json", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.ServeFile(w, r, "api/openapi.json")
        }</span>)

        // Simple Swagger UI via CDN at /docs
        <span class="cov10" title="4">mux.HandleFunc("/docs", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                _, _ = w.Write([]byte(`&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;GPU Telemetry API Docs&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      window.onload = () =&gt; { window.ui = SwaggerUIBundle({ url: '/openapi.json', dom_id: '#swagger-ui' }); };
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;`))
        }</span>)

        // Serve static Swagger UI bundle if generated by Makefile at api/swagger
        <span class="cov10" title="4">mux.Handle("/swagger/", http.StripPrefix("/swagger/", http.FileServer(http.Dir("api/swagger"))))

        return mux</span>
}

func writeJSON(w http.ResponseWriter, status int, v any) <span class="cov5" title="2">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(v)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "sync"
        "syscall"
        "time"

        telemetryv1 "gpu-metric-collector/api/gen"
        "gpu-metric-collector/internal/model"
        "gpu-metric-collector/internal/storage"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

var (
        flagBroker       = flag.String("broker", "127.0.0.1:9000", "Broker gRPC address")
        flagGroup        = flag.String("group", "default", "Consumer group")
        flagBatchSize    = flag.Int("batch", 500, "Collector batch size")
        flagFlushMs      = flag.Int("flush_ms", 1000, "Max flush interval in ms")
        flagWorkers      = flag.Int("workers", 4, "Flush worker count")
        flagMetrics      = flag.String("metrics_addr", ":9102", "Metrics HTTP listen address")
        flagInfluxURL    = flag.String("influx_url", "", "InfluxDB URL, e.g. http://localhost:8086")
        flagInfluxOrg    = flag.String("influx_org", "", "InfluxDB organization")
        flagInfluxBucket = flag.String("influx_bucket", "", "InfluxDB bucket")
        flagInfluxToken  = flag.String("influx_token", "", "InfluxDB API token")
        flagShutdownMs   = flag.Int("shutdown_timeout_ms", 5000, "Max time to wait for flush workers on shutdown (ms)")
)

var (
        metricReceived = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "collector", Name: "messages_received_total", Help: "Messages received from broker.",
        })
        metricBatched = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "collector", Name: "messages_batched_total", Help: "Messages added to a batch.",
        })
        metricFlushed = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "collector", Name: "messages_flushed_total", Help: "Messages flushed to storage.",
        })
        metricDroppedInvalid = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "collector", Name: "messages_dropped_invalid_total", Help: "Messages dropped due to validation.",
        })
        metricFlushErrors = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "collector", Name: "flush_errors_total", Help: "Errors during flush to storage.",
        })
        metricBacklog = prometheus.NewGauge(prometheus.GaugeOpts{
                Namespace: "gpu_telerology", Subsystem: "collector", Name: "backlog", Help: "Current in-memory batch size.",
        })
        metricFlushLatency = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: "gpu_telemetry", Subsystem: "collector", Name: "flush_latency_seconds", Help: "Latency of batch flush to storage.",
                Buckets: prometheus.DefBuckets,
        })
)

func init() <span class="cov1" title="1">{
        prometheus.MustRegister(metricReceived, metricBatched, metricFlushed, metricDroppedInvalid, metricFlushErrors, metricBacklog, metricFlushLatency)
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()

        http.Handle("/metrics", promhttp.Handler())
        go func() </span><span class="cov0" title="0">{
                log.Printf("collector: metrics on %s", *flagMetrics)
                _ = http.ListenAndServe(*flagMetrics, nil)
        }</span>()

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{ &lt;-sigCh; log.Printf("collector: shutdown signal"); cancel() }</span>()

        <span class="cov0" title="0">if err := run(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("collector error: %v", err)
        }</span>
}

func run(ctx context.Context) error <span class="cov0" title="0">{
        var store storage.Store
        // Prefer InfluxDB if configured; otherwise use in-memory
        if stringsTrim(*flagInfluxURL) != "" &amp;&amp; stringsTrim(*flagInfluxOrg) != "" &amp;&amp; stringsTrim(*flagInfluxBucket) != "" &amp;&amp; stringsTrim(*flagInfluxToken) != "" </span><span class="cov0" title="0">{
                s, err := storage.NewInfluxStore(stringsTrim(*flagInfluxURL), stringsTrim(*flagInfluxOrg), stringsTrim(*flagInfluxBucket), stringsTrim(*flagInfluxToken))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("open influx store: %w", err)
                }</span>
                <span class="cov0" title="0">store = s
                log.Printf("collector: using influx store url=%s org=%s bucket=%s", *flagInfluxURL, *flagInfluxOrg, *flagInfluxBucket)</span>
        } else<span class="cov0" title="0"> {
                store = storage.NewMemoryStore()
                log.Printf("collector: using in-memory store")
        }</span>

        <span class="cov0" title="0">conn, err := grpc.Dial(*flagBroker, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dial broker: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        client := telemetryv1.NewTelemetryClient(conn)

        stream, err := client.Subscribe(ctx, &amp;telemetryv1.SubscriptionRequest{Group: *flagGroup})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("subscribe: %w", err)
        }</span>
        <span class="cov0" title="0">return runCollectorLoop(ctx, stream, store, *flagBatchSize, *flagFlushMs, *flagWorkers)</span>
}

type subscribeStream interface {
        Recv() (*telemetryv1.TelemetryData, error)
        Context() context.Context
}

var tickerFn = func(d time.Duration) *time.Ticker <span class="cov0" title="0">{ return time.NewTicker(d) }</span>

func runCollectorLoop(ctx context.Context, stream subscribeStream, store storage.Store, batchSize, flushMs, workers int) error <span class="cov4" title="3">{
        type job struct{ items []model.Telemetry }
        jobs := make(chan job, 64)
        var wg sync.WaitGroup
        for i := 0; i &lt; workers; i++ </span><span class="cov4" title="3">{
                wg.Add(1)
                go func(id int) </span><span class="cov4" title="3">{
                        defer wg.Done()
                        for j := range jobs </span><span class="cov4" title="3">{
                                start := time.Now()
                                n := 0
                                for _, it := range j.items </span><span class="cov8" title="9">{
                                        if err := store.SaveTelemetry(it); err != nil </span><span class="cov0" title="0">{
                                                metricFlushErrors.Inc()
                                                log.Printf("collector: flush error gpu=%s ts=%s: %v", it.GPUId, it.Timestamp.UTC().Format(time.RFC3339), err)
                                        }</span> else<span class="cov8" title="9"> {
                                                metricFlushed.Inc()
                                                n++
                                        }</span>
                                }
                                <span class="cov4" title="3">dur := time.Since(start)
                                metricFlushLatency.Observe(dur.Seconds())
                                log.Printf("collector: worker=%d flushed=%d in %s", id, n, dur)</span>
                        }
                }(i)
        }

        <span class="cov4" title="3">ticker := tickerFn(time.Duration(flushMs) * time.Millisecond)
        defer ticker.Stop()

        batch := make([]model.Telemetry, 0, batchSize)

        flush := func() </span><span class="cov5" title="4">{
                if len(batch) == 0 </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov4" title="3">copyBatch := make([]model.Telemetry, len(batch))
                copy(copyBatch, batch)
                batch = batch[:0]
                metricBacklog.Set(0)
                select </span>{
                case jobs &lt;- job{items: copyBatch}:<span class="cov4" title="3"></span>
                default:<span class="cov0" title="0">
                        jobs &lt;- job{items: copyBatch}</span>
                }
        }

        <span class="cov4" title="3">for </span><span class="cov9" title="12">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        flush()
                        close(jobs)
                        waitDone := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{ wg.Wait(); close(waitDone) }</span>()
                        <span class="cov0" title="0">select </span>{
                        case &lt;-waitDone:<span class="cov0" title="0">
                                return nil</span>
                        case &lt;-time.After(time.Duration(*flagShutdownMs) * time.Millisecond):<span class="cov0" title="0">
                                log.Printf("collector: shutdown timeout after %dms; exiting now", *flagShutdownMs)
                                return nil</span>
                        }
                case &lt;-ticker.C:<span class="cov0" title="0">
                        log.Printf("collector: timer flush batch=%d", len(batch))
                        flush()</span>
                default:<span class="cov9" title="12">
                        msg, err := stream.Recv()
                        if err != nil </span><span class="cov4" title="3">{
                                flush()
                                close(jobs)
                                waitDone := make(chan struct{})
                                go func() </span><span class="cov4" title="3">{ wg.Wait(); close(waitDone) }</span>()
                                <span class="cov4" title="3">select </span>{
                                case &lt;-waitDone:<span class="cov4" title="3">
                                        return fmt.Errorf("recv: %w", err)</span>
                                case &lt;-time.After(time.Duration(*flagShutdownMs) * time.Millisecond):<span class="cov0" title="0">
                                        log.Printf("collector: shutdown timeout after %dms; exiting now", *flagShutdownMs)
                                        return fmt.Errorf("recv: %w", err)</span>
                                }
                        }
                        <span class="cov8" title="9">metricReceived.Inc()
                        if ok := validate(msg); !ok </span><span class="cov0" title="0">{
                                metricDroppedInvalid.Inc()
                                continue</span>
                        }
                        <span class="cov8" title="9">t := toModel(msg)
                        batch = append(batch, t)
                        metricBatched.Inc()
                        metricBacklog.Set(float64(len(batch)))
                        if len(batch) &gt;= batchSize </span><span class="cov1" title="1">{
                                log.Printf("collector: size flush batch=%d", len(batch))
                                flush()
                        }</span>
                }
        }
}

func validate(m *telemetryv1.TelemetryData) bool <span class="cov10" title="14">{
        if m == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="13">if stringsTrim(m.GetGpuId()) == "" </span><span class="cov3" title="2">{
                return false
        }</span>
        <span class="cov9" title="11">if m.GetTs() == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="10">return true</span>
}

func stringsTrim(s string) string <span class="cov9" title="13">{ return strings.TrimSpace(s) }</span>

func toModel(m *telemetryv1.TelemetryData) model.Telemetry <span class="cov9" title="11">{
        out := model.Telemetry{
                GPUId:     m.GetGpuId(),
                Timestamp: m.GetTs().AsTime(),
                Metrics:   map[string]float64{},
        }
        for k, v := range m.GetMetrics() </span><span class="cov4" title="3">{
                out.Metrics[k] = v
        }</span>
        <span class="cov9" title="11">return out</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
    "flag"
    "fmt"
    "log"
    "net"
    "net/http"

    "google.golang.org/grpc"
    health "google.golang.org/grpc/health"
    healthpb "google.golang.org/grpc/health/grpc_health_v1"

    "github.com/prometheus/client_golang/prometheus/promhttp"

    telemetryv1 "gpu-metric-collector/api/gen"
    "gpu-metric-collector/internal/broker"
)

var (
    flagGRPC    = flag.String("grpc_addr", ":9000", "Broker gRPC listen addr")
    flagMetrics = flag.String("metrics_addr", ":9001", "Broker metrics listen addr")
    flagQCap    = flag.Int("queue_cap", 10000, "Inbound queue capacity")
    flagSBuf    = flag.Int("sub_buf", 256, "Per-subscriber buffer")
)

func main() <span class="cov0" title="0">{
    flag.Parse()
    addr := *flagGRPC
    lis, err := net.Listen("tcp", addr)
    if err != nil </span><span class="cov0" title="0">{
        log.Fatalf("listen: %v", err)
    }</span>

    <span class="cov0" title="0">grpcServer := grpc.NewServer()

    // health service
    h := health.NewServer()
    healthpb.RegisterHealthServer(grpcServer, h)

    // telemetry broker
    telemetryv1.RegisterTelemetryServer(grpcServer, broker.NewServer(*flagQCap, *flagSBuf))

    // metrics server
    http.Handle("/metrics", promhttp.Handler())
    go func() </span><span class="cov0" title="0">{
        maddr := *flagMetrics
        fmt.Printf("mq-broker: metrics on %s\n", maddr)
        if err := http.ListenAndServe(maddr, nil); err != nil </span><span class="cov0" title="0">{
            log.Printf("metrics serve error: %v", err)
        }</span>
    }()

    <span class="cov0" title="0">fmt.Printf("mq-broker: gRPC listening on %s\n", addr)
    if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
        log.Fatalf("serve: %v", err)
    }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "bufio"
        "context"
        "encoding/csv"
        "flag"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "strings"
        "syscall"
        "time"

        telemetryv1 "gpu-metric-collector/api/gen"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/timestamppb"
)

var (
        flagCSV       = flag.String("csv", "dcgm_metrics_20250718_134233.csv", "Path to telemetry CSV file")
        flagBroker    = flag.String("broker", "127.0.0.1:9000", "Broker gRPC address")
        flagBatchSize = flag.Int("batch", 50, "Batch size for publish")
        flagTickMs    = flag.Int("tick_ms", 500, "Flush interval in ms")
        flagMetrics   = flag.String("metrics_addr", ":9101", "Metrics HTTP listen address")
        flagProducer  = flag.String("producer_id", "streamer-1", "Producer ID")
        flagHost      = flag.String("host_id", "", "Override host ID (default: os.Hostname)")
)

var (
        metricIngested = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "streamer", Name: "rows_ingested_total", Help: "CSV rows read.",
        })
        metricPublished = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "streamer", Name: "items_published_total", Help: "Telemetry items published.",
        })
        metricBackpressure = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "streamer", Name: "backpressure_total", Help: "Backpressure responses from broker.",
        })
        metricErrors = prometheus.NewCounter(prometheus.CounterOpts{
                Namespace: "gpu_telemetry", Subsystem: "streamer", Name: "errors_total", Help: "Errors encountered.",
        })
        metricPublishLatency = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: "gpu_telemetry", Subsystem: "streamer", Name: "publish_latency_seconds", Help: "Latency of PublishBatch calls.",
                Buckets: prometheus.DefBuckets,
        })
        metricBatchPending = prometheus.NewGauge(prometheus.GaugeOpts{
                Namespace: "gpu_telemetry", Subsystem: "streamer", Name: "batch_pending", Help: "Current items buffered before publish.",
        })
)

func init() <span class="cov1" title="1">{
        prometheus.MustRegister(metricIngested, metricPublished, metricBackpressure, metricErrors, metricPublishLatency, metricBatchPending)
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()

        hostname := *flagHost
        if hostname == "" </span><span class="cov0" title="0">{
                if h, err := os.Hostname(); err == nil </span><span class="cov0" title="0">{
                        hostname = h
                }</span> else<span class="cov0" title="0"> {
                        hostname = "unknown-host"
                }</span>
        }

        <span class="cov0" title="0">http.Handle("/metrics", promhttp.Handler())
        go func() </span><span class="cov0" title="0">{
                log.Printf("streamer: metrics on %s", *flagMetrics)
                _ = http.ListenAndServe(*flagMetrics, nil)
        }</span>()

        <span class="cov0" title="0">conn, err := grpc.Dial(*flagBroker, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("dial broker: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        client := telemetryv1.NewTelemetryClient(conn)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigCh
                log.Printf("streamer: received shutdown signal, flushing...")
                cancel()
        }</span>()

        <span class="cov0" title="0">if err := runStreamer(ctx, client, hostname, *flagProducer, *flagCSV, *flagBatchSize, time.Duration(*flagTickMs)*time.Millisecond); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("streamer error: %v", err)
        }</span>
}

func runStreamer(ctx context.Context, client telemetryv1.TelemetryClient, hostID, producerID, csvPath string, batchSize int, tick time.Duration) error <span class="cov0" title="0">{
        file, err := os.Open(csvPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open csv: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        reader := csv.NewReader(bufio.NewReader(file))
        reader.FieldsPerRecord = -1
        headers, err := reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read header: %w", err)
        }</span>
        <span class="cov0" title="0">for i := range headers </span><span class="cov0" title="0">{
                headers[i] = strings.TrimSpace(strings.ToLower(headers[i]))
        }</span>

        <span class="cov0" title="0">var batch []*telemetryv1.TelemetryData
        flushTicker := time.NewTicker(tick)
        defer flushTicker.Stop()

        backoff := 100 * time.Millisecond
        const backoffMax = 5 * time.Second

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                drainRemaining(context.Background(), client, batch, &amp;backoff, backoffMax)
                        }</span>
                        <span class="cov0" title="0">log.Printf("streamer: exiting")
                        return nil</span>
                case &lt;-flushTicker.C:<span class="cov0" title="0">
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                log.Printf("streamer: timer flush batch=%d", len(batch))
                                drainRemaining(ctx, client, batch, &amp;backoff, backoffMax)
                                batch = batch[:0]
                                metricBatchPending.Set(0)
                        }</span>
                default:<span class="cov0" title="0">
                        rec, err := reader.Read()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        if _, err2 := file.Seek(0, 0); err2 != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("seek: %w", err2)
                                        }</span>
                                        <span class="cov0" title="0">reader = csv.NewReader(bufio.NewReader(file))
                                        reader.FieldsPerRecord = -1
                                        headers, err = reader.Read()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("re-read header: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">for i := range headers </span><span class="cov0" title="0">{
                                                headers[i] = strings.TrimSpace(strings.ToLower(headers[i]))
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("csv read: %w", err)</span>
                        }
                        <span class="cov0" title="0">metricIngested.Inc()
                        item := toTelemetry(headers, rec, hostID, producerID)
                        fmt.Printf("item - %+v \n", item)
                        if item != nil &amp;&amp; item.GpuId != "" &amp;&amp; item.GpuId != "gpu-unknown" </span><span class="cov0" title="0">{
                                batch = append(batch, item)
                        }</span>
                        <span class="cov0" title="0">metricBatchPending.Set(float64(len(batch)))
                        if len(batch) &gt;= batchSize </span><span class="cov0" title="0">{
                                log.Printf("streamer: size flush batch=%d", len(batch))
                                drainRemaining(ctx, client, batch, &amp;backoff, backoffMax)
                                batch = batch[:0]
                                metricBatchPending.Set(0)
                        }</span>
                }
        }
}

// drainRemaining publishes remaining items with partial-accept and backpressure retry handling.
func drainRemaining(ctx context.Context, client telemetryv1.TelemetryClient, remaining []*telemetryv1.TelemetryData, backoff *time.Duration, backoffMax time.Duration) <span class="cov4" title="2">{
        for len(remaining) &gt; 0 </span><span class="cov7" title="4">{
                // exit promptly if shutdown requested
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov7" title="4"></span>
                }
                <span class="cov7" title="4">acc, bp, err := publishBatch(ctx, client, remaining)
                if err != nil </span><span class="cov0" title="0">{
                        metricErrors.Inc()
                        // if context canceled, exit without further retries
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("streamer: publish error: %v (retrying in %s)", err, backoff.String())
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(*backoff):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">if *backoff &lt; backoffMax </span><span class="cov0" title="0">{
                                *backoff *= 2
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov7" title="4">if bp </span><span class="cov4" title="2">{
                        if acc &gt; 0 </span><span class="cov1" title="1">{
                                remaining = remaining[acc:]
                                log.Printf("streamer: backpressure accepted=%d remaining=%d", acc, len(remaining))
                        }</span> else<span class="cov1" title="1"> {
                                log.Printf("streamer: backpressure accepted=0 remaining=%d", len(remaining))
                        }</span>
                        <span class="cov4" title="2">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(*backoff):<span class="cov4" title="2"></span>
                        }
                        <span class="cov4" title="2">if *backoff &lt; backoffMax </span><span class="cov4" title="2">{
                                *backoff *= 2
                        }</span>
                        <span class="cov4" title="2">continue</span>
                }
                // all accepted
                <span class="cov4" title="2">remaining = remaining[:0]
                *backoff = 100 * time.Millisecond</span>
        }
}

// publishBatch returns (accepted, backpressure, err)
func publishBatch(ctx context.Context, client telemetryv1.TelemetryClient, batch []*telemetryv1.TelemetryData) (int, bool, error) <span class="cov10" title="7">{
        start := time.Now()
        resp, err := client.PublishBatch(ctx, &amp;telemetryv1.TelemetryBatch{Items: batch})
        metricPublishLatency.Observe(time.Since(start).Seconds())
        if err != nil </span><span class="cov1" title="1">{
                return 0, false, err
        }</span>
        <span class="cov9" title="6">accepted := int(resp.GetAccepted())
        metricPublished.Add(float64(accepted))
        if resp.GetStatus() == "BACKPRESSURE" </span><span class="cov6" title="3">{
                metricBackpressure.Inc()
                return accepted, true, nil
        }</span>
        <span class="cov6" title="3">log.Printf("streamer: published ok accepted=%d", accepted)
        return accepted, false, nil</span>
}

func toTelemetry(headers, rec []string, hostID, producerID string) *telemetryv1.TelemetryData <span class="cov1" title="1">{
        gpuID := ""
        metrics := make(map[string]float64)
        // detect a metric-name column common in DCGM/Influx exports
        fieldNameIdx := -1
        for i, h2 := range headers </span><span class="cov6" title="3">{
                switch h2 </span>{
                case "_field", "field_name", "metric_name", "metric", "name":<span class="cov0" title="0">
                        fieldNameIdx = i</span>
                }
        }
        <span class="cov1" title="1">for i, h := range headers </span><span class="cov6" title="3">{
                if i &gt;= len(rec) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="3">val := strings.TrimSpace(rec[i])
                switch h </span>{
                case "gpu", "gpu_id", "gpuuuid", "gpu_uuid":<span class="cov1" title="1">
                        gpuID = val
                        continue</span>
                case "host", "host_id", "hostname":<span class="cov0" title="0">
                        continue</span>
                }
                <span class="cov4" title="2">if f, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov4" title="2">{
                        // If numeric column is generic and we have a metric-name column, use that as key
                        if (h == "value" || h == "_value") &amp;&amp; fieldNameIdx &gt;= 0 &amp;&amp; fieldNameIdx &lt; len(rec) </span><span class="cov0" title="0">{
                                key := strings.TrimSpace(rec[fieldNameIdx])
                                key = strings.ToLower(key)
                                if key != "" </span><span class="cov0" title="0">{
                                        metrics[key] = f
                                        continue</span>
                                }
                        }
                        <span class="cov4" title="2">metrics[h] = f</span>
                }
        }
        <span class="cov1" title="1">if gpuID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;telemetryv1.TelemetryData{
                ProducerId: producerID,
                HostId:     hostID,
                GpuId:      gpuID,
                Ts:         timestamppb.Now(),
                Metrics:    metrics,
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package broker

import (
    "context"
    "errors"
    "log"
    "sync"
    "time"

    telemetryv1 "gpu-metric-collector/api/gen"

    "github.com/prometheus/client_golang/prometheus"
)

type subscriber struct {
    id string
    ch chan *telemetryv1.TelemetryData
}

type Server struct {
    telemetryv1.UnimplementedTelemetryServer

    mu       sync.Mutex
    subs     []*subscriber
    next     int
    inbound  chan *telemetryv1.TelemetryData
    queueCap int
    subBuf   int
}

var (
    metricEnqueued = prometheus.NewCounter(prometheus.CounterOpts{
        Namespace: "gpu_telemetry",
        Subsystem: "broker",
        Name:      "messages_enqueued_total",
        Help:      "Total messages accepted into the broker queue.",
    })
    metricDelivered = prometheus.NewCounter(prometheus.CounterOpts{
        Namespace: "gpu_telemetry",
        Subsystem: "broker",
        Name:      "messages_delivered_total",
        Help:      "Total messages delivered to subscribers.",
    })
    metricBackpressure = prometheus.NewCounter(prometheus.CounterOpts{
        Namespace: "gpu_telemetry",
        Subsystem: "broker",
        Name:      "backpressure_events_total",
        Help:      "Total backpressure events when queue was full.",
    })
    metricRequeued = prometheus.NewCounter(prometheus.CounterOpts{
        Namespace: "gpu_telemetry",
        Subsystem: "broker",
        Name:      "messages_requeued_total",
        Help:      "Total messages requeued due to subscriber send errors.",
    })
    metricSubscribers = prometheus.NewGauge(prometheus.GaugeOpts{
        Namespace: "gpu_telemetry",
        Subsystem: "broker",
        Name:      "subscribers",
        Help:      "Current number of active subscribers.",
    })
    metricQueueDepth = prometheus.NewGauge(prometheus.GaugeOpts{
        Namespace: "gpu_telemetry",
        Subsystem: "broker",
        Name:      "queue_depth",
        Help:      "Current depth of the inbound queue.",
    })
)

func init() <span class="cov1" title="1">{
    prometheus.MustRegister(metricEnqueued, metricDelivered, metricBackpressure, metricRequeued, metricSubscribers, metricQueueDepth)
}</span>

func NewServer(queueCap, subBuf int) *Server <span class="cov4" title="3">{
    s := &amp;Server{
        inbound:  make(chan *telemetryv1.TelemetryData, queueCap),
        queueCap: queueCap,
        subBuf:   subBuf,
    }
    go s.dispatcher()
    // queue depth sampler
    go func() </span><span class="cov4" title="3">{
        ticker := time.NewTicker(200 * time.Millisecond)
        defer ticker.Stop()
        for range ticker.C </span><span class="cov0" title="0">{
            metricQueueDepth.Set(float64(len(s.inbound)))
        }</span>
    }()
    <span class="cov4" title="3">return s</span>
}

func (s *Server) PublishBatch(ctx context.Context, req *telemetryv1.TelemetryBatch) (*telemetryv1.PublishResponse, error) <span class="cov4" title="3">{
    if req == nil </span><span class="cov0" title="0">{
        return nil, errors.New("nil request")
    }</span>
    <span class="cov4" title="3">accepted := 0
    for i := range req.Items </span><span class="cov6" title="5">{
        item := req.Items[i]
        select </span>{
        case s.inbound &lt;- item:<span class="cov6" title="4">
            accepted++
            metricEnqueued.Inc()
            if accepted%1000 == 0 </span><span class="cov0" title="0">{
                log.Printf("broker: enqueued accepted=%d", accepted)
            }</span>
        default:<span class="cov1" title="1">
            metricBackpressure.Inc()
            log.Printf("broker: backpressure after accepted=%d depth=%d", accepted, len(s.inbound))
            return &amp;telemetryv1.PublishResponse{Accepted: int64(accepted), Status: "BACKPRESSURE"}, nil</span>
        }
    }
    <span class="cov3" title="2">return &amp;telemetryv1.PublishResponse{Accepted: int64(accepted), Status: "OK"}, nil</span>
}

func (s *Server) Subscribe(req *telemetryv1.SubscriptionRequest, stream telemetryv1.Telemetry_SubscribeServer) error <span class="cov6" title="4">{
    id := time.Now().UTC().Format("20060102T150405.000000000")
    sub := &amp;subscriber{
        id: id,
        ch: make(chan *telemetryv1.TelemetryData, s.subBuf),
    }
    s.addSubscriber(sub)
    log.Printf("broker: subscriber added id=%s", id)
    defer s.removeSubscriber(sub.id)

    for </span><span class="cov8" title="8">{
        select </span>{
        case &lt;-stream.Context().Done():<span class="cov4" title="3">
            return nil</span>
        case msg := &lt;-sub.ch:<span class="cov6" title="5">
            if msg == nil </span><span class="cov0" title="0">{
                return nil
            }</span>
            <span class="cov6" title="5">if err := stream.Send(msg); err != nil </span><span class="cov1" title="1">{
                // drop subscriber, re-enqueue the message
                s.removeSubscriber(sub.id)
                select </span>{
                case s.inbound &lt;- msg:<span class="cov1" title="1">
                    metricRequeued.Inc()
                    log.Printf("broker: requeued after send error")</span>
                default:<span class="cov0" title="0"></span>
                    // if queue is full, drop on floor to avoid deadlock
                }
                <span class="cov1" title="1">return err</span>
            }
            <span class="cov6" title="4">metricDelivered.Inc()</span>
        }
    }
}

func (s *Server) addSubscriber(sub *subscriber) <span class="cov6" title="4">{
    s.mu.Lock()
    defer s.mu.Unlock()
    s.subs = append(s.subs, sub)
    metricSubscribers.Set(float64(len(s.subs)))
}</span>

func (s *Server) removeSubscriber(id string) <span class="cov6" title="5">{
    s.mu.Lock()
    defer s.mu.Unlock()
    n := 0
    for _, sub := range s.subs </span><span class="cov7" title="6">{
        if sub.id != id </span><span class="cov3" title="2">{
            s.subs[n] = sub
            n++
        }</span>
    }
    <span class="cov6" title="5">s.subs = s.subs[:n]
    metricSubscribers.Set(float64(len(s.subs)))
    log.Printf("broker: subscriber removed id=%s remain=%d", id, len(s.subs))</span>
}

func (s *Server) snapshotSubs() []*subscriber <span class="cov10" title="12">{
    s.mu.Lock()
    defer s.mu.Unlock()
    out := make([]*subscriber, len(s.subs))
    copy(out, s.subs)
    return out
}</span>

func (s *Server) dispatcher() <span class="cov4" title="3">{
    for msg := range s.inbound </span><span class="cov6" title="5">{
        for </span><span class="cov10" title="12">{
            subs := s.snapshotSubs()
            if len(subs) == 0 </span><span class="cov8" title="9">{
                // no subscribers yet; brief sleep and retry
                time.Sleep(5 * time.Millisecond)
                continue</span>
            }
            <span class="cov4" title="3">delivered := false
            start := s.next
            for i := 0; i &lt; len(subs); i++ </span><span class="cov7" title="6">{
                idx := (start + i) % len(subs)
                sel := subs[idx]
                select </span>{
                case sel.ch &lt;- msg:<span class="cov7" title="6">
                    // advance round-robin pointer
                    s.mu.Lock()
                    s.next = (idx + 1) % len(subs)
                    s.mu.Unlock()
                    delivered = true
                    break</span>
                default:<span class="cov0" title="0"></span>
                    // target is full, try next
                }
            }
            <span class="cov4" title="3">if delivered </span><span class="cov4" title="3">{
                break</span>
            }
            // all subscriber queues are full; brief backoff
            <span class="cov0" title="0">time.Sleep(1 * time.Millisecond)</span>
        }
    }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package storage

import (
        "context"
        "fmt"
        "sort"
        "time"

        "gpu-metric-collector/internal/model"

        influxdb2 "github.com/influxdata/influxdb-client-go/v2"
        "github.com/influxdata/influxdb-client-go/v2/api"
)

// InfluxStore implements Store backed by InfluxDB v2.
type InfluxStore struct {
        client influxdb2.Client
        org    string
        bucket string
        wapi   api.WriteAPIBlocking
        qapi   api.QueryAPI
}

// NewInfluxStore builds a Store using InfluxDB v2 client.
// url example: http://localhost:8086
// org: your org name
// bucket: your bucket name
// token: auth token (PAT)
func NewInfluxStore(url, org, bucket, token string) (Store, error) <span class="cov0" title="0">{
        if url == "" || org == "" || bucket == "" || token == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("influx: missing url/org/bucket/token")
        }</span>
        <span class="cov0" title="0">client := influxdb2.NewClient(url, token)
        st := &amp;InfluxStore{
                client: client,
                org:    org,
                bucket: bucket,
                wapi:   client.WriteAPIBlocking(org, bucket),
                qapi:   client.QueryAPI(org),
        }
        return st, nil</span>
}

func (s *InfluxStore) SaveTelemetry(t model.Telemetry) error <span class="cov0" title="0">{
        // measurement: telemetry
        // tag: gpu_id
        // fields: metrics map
        if len(t.Metrics) == 0 </span><span class="cov0" title="0">{
                // still write a heartbeat point so GPU is discoverable
                fields := map[string]interface{}{"_heartbeat": 1}
                p := influxdb2.NewPoint("telemetry", map[string]string{"gpu_id": t.GPUId}, fields, t.Timestamp)
                return s.wapi.WritePoint(context.Background(), p)
        }</span>
        <span class="cov0" title="0">fields := make(map[string]interface{}, len(t.Metrics))
        for k, v := range t.Metrics </span><span class="cov0" title="0">{
                fields[k] = v
        }</span>
        <span class="cov0" title="0">p := influxdb2.NewPoint("telemetry", map[string]string{"gpu_id": t.GPUId}, fields, t.Timestamp)
        return s.wapi.WritePoint(context.Background(), p)</span>
}

func (s *InfluxStore) ListGPUs() ([]string, error) <span class="cov0" title="0">{
        // Query distinct tag values for gpu_id across data in bucket
        // Flux: from |&gt; range(start: 0) |&gt; filter(m == "telemetry") |&gt; group(columns: ["gpu_id"]) |&gt; distinct(column: "gpu_id")
        q := `from(bucket: "` + s.bucket + `")
  |&gt; range(start: 0)
  |&gt; filter(fn: (r) =&gt; r._measurement == "telemetry")
  |&gt; keep(columns: ["gpu_id"]) 
  |&gt; group()
  |&gt; distinct(column: "gpu_id")`
        res, err := s.qapi.Query(context.Background(), q)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("influx list gpus: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Close()
        set := map[string]struct{}{}
        for res.Next() </span><span class="cov0" title="0">{
                // After distinct(column: "gpu_id"), the distinct value appears in _value
                v := res.Record().Value()
                if v == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">id, ok := v.(string)
                if !ok || id == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">set[id] = struct{}{}</span>
        }
        <span class="cov0" title="0">if res.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("influx list gpus: %w", res.Err())
        }</span>
        <span class="cov0" title="0">out := make([]string, 0, len(set))
        for id := range set </span><span class="cov0" title="0">{
                out = append(out, id)
        }</span>
        <span class="cov0" title="0">sort.Strings(out)
        return out, nil</span>
}

// timeLiteral returns a Flux time literal suitable for range(), e.g., time(v: "2026-01-27T00:00:00Z").
func timeLiteral(t time.Time) string <span class="cov0" title="0">{
        return fmt.Sprintf("time(v: %q)", t.UTC().Format(time.RFC3339))
}</span>

func (s *InfluxStore) QueryTelemetry(gpuID string, start, end *time.Time) ([]model.Telemetry, error) <span class="cov0" title="0">{
        if gpuID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gpuID required")
        }</span>
        <span class="cov0" title="0">startExpr := "0"
        if start != nil </span><span class="cov0" title="0">{
                startExpr = timeLiteral(*start)
        }</span>
        <span class="cov0" title="0">stopExpr := ""
        if end != nil </span><span class="cov0" title="0">{
                stopExpr = ", stop: " + timeLiteral(*end)
        }</span>
        // Pivot fields so each timestamp becomes one row with all metric columns
        <span class="cov0" title="0">q := fmt.Sprintf(`from(bucket: "%s")
  |&gt; range(start: %s%s)
  |&gt; filter(fn: (r) =&gt; r._measurement == "telemetry" and r.gpu_id == "%s")
  |&gt; pivot(rowKey:["_time"], columnKey:["_field"], valueColumn:"_value")
  |&gt; sort(columns: ["_time"], desc: false)
`, s.bucket, startExpr, stopExpr, gpuID)
        res, err := s.qapi.Query(context.Background(), q)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("influx query: %w; flux=%s", err, q)
        }</span>
        <span class="cov0" title="0">defer res.Close()
        var out []model.Telemetry
        for res.Next() </span><span class="cov0" title="0">{
                rec := res.Record()
                ts := rec.Time().UTC()
                metrics := map[string]float64{}
                // Collect all columns except metadata
                for k, v := range rec.Values() </span><span class="cov0" title="0">{
                        if k == "_time" || k == "_measurement" || k == "result" || k == "table" || k == "gpu_id" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">switch val := v.(type) </span>{
                        case int64:<span class="cov0" title="0">
                                metrics[k] = float64(val)</span>
                        case float64:<span class="cov0" title="0">
                                metrics[k] = val</span>
                        case int32:<span class="cov0" title="0">
                                metrics[k] = float64(val)</span>
                        case uint64:<span class="cov0" title="0">
                                metrics[k] = float64(val)</span>
                        case uint32:<span class="cov0" title="0">
                                metrics[k] = float64(val)</span>
                        }
                }
                <span class="cov0" title="0">out = append(out, model.Telemetry{GPUId: gpuID, Timestamp: ts, Metrics: metrics})</span>
        }
        <span class="cov0" title="0">if err := res.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("influx query: %w", err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func timeToRFC3339(t time.Time) string <span class="cov0" title="0">{
        return fmt.Sprintf("%q", t.UTC().Format(time.RFC3339))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package storage

import (
        "sort"
        "sync"
        "time"

        "gpu-metric-collector/internal/model"
)

// MemoryStore is a threadsafe in-memory implementation of Store.
type MemoryStore struct {
        mu   sync.RWMutex
        data map[string][]model.Telemetry // gpuID -&gt; ordered by time asc
}

func NewMemoryStore() *MemoryStore <span class="cov4" title="3">{
        return &amp;MemoryStore{data: make(map[string][]model.Telemetry)}
}</span>

func (m *MemoryStore) SaveTelemetry(t model.Telemetry) error <span class="cov9" title="10">{
        m.mu.Lock()
        defer m.mu.Unlock()
        s := m.data[t.GPUId]
        s = append(s, t)
        // maintain order by timestamp (append then sort stable; small overhead acceptable for demo)
        sort.SliceStable(s, func(i, j int) bool </span><span class="cov10" title="13">{ return s[i].Timestamp.Before(s[j].Timestamp) }</span>)
        <span class="cov9" title="10">m.data[t.GPUId] = s
        return nil</span>
}

func (m *MemoryStore) ListGPUs() ([]string, error) <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        out := make([]string, 0, len(m.data))
        for id := range m.data </span><span class="cov3" title="2">{
                out = append(out, id)
        }</span>
        <span class="cov1" title="1">sort.Strings(out)
        return out, nil</span>
}

func (m *MemoryStore) QueryTelemetry(gpuID string, start, end *time.Time) ([]model.Telemetry, error) <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        s := m.data[gpuID]
        if start == nil &amp;&amp; end == nil </span><span class="cov1" title="1">{
                out := make([]model.Telemetry, len(s))
                copy(out, s)
                return out, nil
        }</span>
        <span class="cov1" title="1">var out []model.Telemetry
        for _, it := range s </span><span class="cov6" title="5">{
                if start != nil &amp;&amp; it.Timestamp.Before(*start) </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="4">if end != nil &amp;&amp; it.Timestamp.After(*end) </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="3">out = append(out, it)</span>
        }
        <span class="cov1" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package storage

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "gpu-metric-collector/internal/model"

        _ "modernc.org/sqlite"
)

// SQLiteStore implements Store backed by a single table with JSON metrics.
type SQLiteStore struct {
        db *sql.DB
}

// NewSQLiteStore opens (and initializes) an SQLite database.
// Example DSN: file:gpu-telemetry.db?_busy_timeout=5000
func NewSQLiteStore(dsn string) (Store, error) <span class="cov0" title="0">{
        db, err := sql.Open("sqlite", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open sqlite: %w", err)
        }</span>
        <span class="cov0" title="0">if err := initSchema(db); err != nil </span><span class="cov0" title="0">{
                _ = db.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;SQLiteStore{db: db}, nil</span>
}

func initSchema(db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.Exec(`
CREATE TABLE IF NOT EXISTS telemetry (
  gpu_id TEXT NOT NULL,
  ts INTEGER NOT NULL,
  metrics TEXT NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_telemetry_gpu_ts ON telemetry(gpu_id, ts);
`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("init schema: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SQLiteStore) SaveTelemetry(t model.Telemetry) error <span class="cov0" title="0">{
        b, err := json.Marshal(t.Metrics)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal metrics: %w", err)
        }</span>
        <span class="cov0" title="0">_, err = s.db.Exec(`INSERT INTO telemetry(gpu_id, ts, metrics) VALUES(?, ?, ?)`, t.GPUId, t.Timestamp.Unix(), string(b))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert telemetry: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SQLiteStore) ListGPUs() ([]string, error) <span class="cov0" title="0">{
        rows, err := s.db.Query(`SELECT DISTINCT gpu_id FROM telemetry ORDER BY gpu_id`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list gpus: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []string
        for rows.Next() </span><span class="cov0" title="0">{
                var id string
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">out = append(out, id)</span>
        }
        <span class="cov0" title="0">return out, rows.Err()</span>
}

func (s *SQLiteStore) QueryTelemetry(gpuID string, start, end *time.Time) ([]model.Telemetry, error) <span class="cov0" title="0">{
        q := `SELECT ts, metrics FROM telemetry WHERE gpu_id = ?`
        args := []any{gpuID}
        if start != nil </span><span class="cov0" title="0">{
                q += ` AND ts &gt;= ?`
                args = append(args, start.Unix())
        }</span>
        <span class="cov0" title="0">if end != nil </span><span class="cov0" title="0">{
                q += ` AND ts &lt;= ?`
                args = append(args, end.Unix())
        }</span>
        <span class="cov0" title="0">q += ` ORDER BY ts ASC`
        rows, err := s.db.Query(q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query telemetry: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var out []model.Telemetry
        for rows.Next() </span><span class="cov0" title="0">{
                var ts int64
                var mjson string
                if err := rows.Scan(&amp;ts, &amp;mjson); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">m := map[string]float64{}
                if err := json.Unmarshal([]byte(mjson), &amp;m); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unmarshal metrics: %w", err)
                }</span>
                <span class="cov0" title="0">out = append(out, model.Telemetry{GPUId: gpuID, Timestamp: time.Unix(ts, 0).UTC(), Metrics: m})</span>
        }
        <span class="cov0" title="0">return out, rows.Err()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
